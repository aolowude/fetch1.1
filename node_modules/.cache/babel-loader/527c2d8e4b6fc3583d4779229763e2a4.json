{"ast":null,"code":"import { useDomEvent } from \"framer-motion\";\nimport { spring } from \"popmotion\";\nimport { mix } from \"@popmotion/popcorn\";\nimport { debounce } from \"lodash\";\n// Absolute distance a wheel scroll event can travel outside of\n// the defined constraints before we fire a \"snap back\" animation\nvar deltaThreshold = 5; // If wheel event fires beyond constraints, multiple the delta by this amount\n\nvar elasticFactor = 0.2;\n\nfunction springTo(value, from, to) {\n  if (value.isAnimating()) return;\n  value.start(function (complete) {\n    var animation = spring({\n      from: from,\n      to: to,\n      velocity: value.getVelocity(),\n      stiffness: 400,\n      damping: 40\n    }).start({\n      update: function update(v) {\n        return value.set(v);\n      },\n      complete: complete\n    });\n    return function () {\n      return animation.stop();\n    };\n  });\n}\n\nvar debouncedSpringTo = debounce(springTo, 100);\n/**\n * Re-implements wheel scroll for overlflow: hidden elements.\n *\n * Adds Apple Watch crown-style constraints, where the user\n * must continue to input wheel events of a certain delta at a certain\n * speed or the scrollable container will spring back to the nearest\n * constraint.\n *\n * Currently achieves this using event.deltaY and a debounce, which\n * feels pretty good during direct input but it'd be better to increase\n * the deltaY threshold during momentum scroll.\n *\n * TODOs before inclusion in Framer Motion:\n * - Detect momentum scroll and increase delta threshold before spring\n * - Remove padding hack\n * - Handle x-axis\n * - Perhaps handle arrow and space keyboard events?\n *\n * @param ref - Ref of the Element to attach listener to\n * @param y - MotionValue for the scrollable element - might be different to the Element\n * @param constraints - top/bottom scroll constraints in pixels.\n * @param isActive - `true` if this listener should fire.\n */\n\nexport function useWheelScroll(ref, y, constraints, onWheelCallback, isActive) {\n  var onWheel = function onWheel(event) {\n    event.preventDefault();\n    var currentY = y.get();\n    var newY = currentY - event.deltaY;\n    var startedAnimation = false;\n    var isWithinBounds = constraints && newY >= constraints.top && newY <= constraints.bottom;\n\n    if (constraints && !isWithinBounds) {\n      newY = mix(currentY, newY, elasticFactor);\n\n      if (newY < constraints.top) {\n        if (event.deltaY <= deltaThreshold) {\n          springTo(y, newY, constraints.top);\n          startedAnimation = true;\n        } else {\n          debouncedSpringTo(y, newY, constraints.top);\n        }\n      }\n\n      if (newY > constraints.bottom) {\n        if (event.deltaY >= -deltaThreshold) {\n          springTo(y, newY, constraints.bottom);\n          startedAnimation = true;\n        } else {\n          debouncedSpringTo(y, newY, constraints.bottom);\n        }\n      }\n    }\n\n    if (!startedAnimation) {\n      y.stop();\n      y.set(newY);\n    } else {\n      debouncedSpringTo.cancel();\n    }\n\n    onWheelCallback(event);\n  };\n\n  useDomEvent(ref, \"wheel\", isActive && onWheel, {\n    passive: false\n  });\n}","map":{"version":3,"sources":["/Users/aolowude/git/fetch1.1/src/utils/use-wheel-scroll.ts"],"names":["useDomEvent","spring","mix","debounce","deltaThreshold","elasticFactor","springTo","value","from","to","isAnimating","start","complete","animation","velocity","getVelocity","stiffness","damping","update","v","set","stop","debouncedSpringTo","useWheelScroll","ref","y","constraints","onWheelCallback","isActive","onWheel","event","preventDefault","currentY","get","newY","deltaY","startedAnimation","isWithinBounds","top","bottom","cancel","passive"],"mappings":"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","sourcesContent":["import { RefObject } from \"react\";\nimport { useDomEvent, MotionValue } from \"framer-motion\";\nimport { spring } from \"popmotion\";\nimport { mix } from \"@popmotion/popcorn\";\nimport { debounce } from \"lodash\";\n\ninterface Constraints {\n  top: number;\n  bottom: number;\n}\n\n// Absolute distance a wheel scroll event can travel outside of\n// the defined constraints before we fire a \"snap back\" animation\nconst deltaThreshold = 5;\n\n// If wheel event fires beyond constraints, multiple the delta by this amount\nconst elasticFactor = 0.2;\n\nfunction springTo(value: MotionValue, from: number, to: number) {\n  if (value.isAnimating()) return;\n\n  value.start(complete => {\n    const animation = spring({\n      from,\n      to,\n      velocity: value.getVelocity(),\n      stiffness: 400,\n      damping: 40\n    }).start({\n      update: (v: number) => value.set(v),\n      complete\n    });\n\n    return () => animation.stop();\n  });\n}\n\nconst debouncedSpringTo = debounce(springTo, 100);\n\n/**\n * Re-implements wheel scroll for overlflow: hidden elements.\n *\n * Adds Apple Watch crown-style constraints, where the user\n * must continue to input wheel events of a certain delta at a certain\n * speed or the scrollable container will spring back to the nearest\n * constraint.\n *\n * Currently achieves this using event.deltaY and a debounce, which\n * feels pretty good during direct input but it'd be better to increase\n * the deltaY threshold during momentum scroll.\n *\n * TODOs before inclusion in Framer Motion:\n * - Detect momentum scroll and increase delta threshold before spring\n * - Remove padding hack\n * - Handle x-axis\n * - Perhaps handle arrow and space keyboard events?\n *\n * @param ref - Ref of the Element to attach listener to\n * @param y - MotionValue for the scrollable element - might be different to the Element\n * @param constraints - top/bottom scroll constraints in pixels.\n * @param isActive - `true` if this listener should fire.\n */\nexport function useWheelScroll(\n  ref: RefObject<Element>,\n  y: MotionValue<number>,\n  constraints: Constraints | null,\n  onWheelCallback: (e: WheelEvent) => void,\n  isActive: boolean\n) {\n  const onWheel = (event: WheelEvent) => {\n    event.preventDefault();\n\n    const currentY = y.get();\n    let newY = currentY - event.deltaY;\n    let startedAnimation = false;\n    const isWithinBounds =\n      constraints && newY >= constraints.top && newY <= constraints.bottom;\n\n    if (constraints && !isWithinBounds) {\n      newY = mix(currentY, newY, elasticFactor);\n\n      if (newY < constraints.top) {\n        if (event.deltaY <= deltaThreshold) {\n          springTo(y, newY, constraints.top);\n          startedAnimation = true;\n        } else {\n          debouncedSpringTo(y, newY, constraints.top);\n        }\n      }\n\n      if (newY > constraints.bottom) {\n        if (event.deltaY >= -deltaThreshold) {\n          springTo(y, newY, constraints.bottom);\n          startedAnimation = true;\n        } else {\n          debouncedSpringTo(y, newY, constraints.bottom);\n        }\n      }\n    }\n\n    if (!startedAnimation) {\n      y.stop();\n      y.set(newY);\n    } else {\n      debouncedSpringTo.cancel();\n    }\n\n    onWheelCallback(event);\n  };\n\n  useDomEvent(ref, \"wheel\", isActive && onWheel, { passive: false });\n}\n"]},"metadata":{},"sourceType":"module"}